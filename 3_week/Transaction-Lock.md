# <트랜잭션 DB Lock>

### 락, 트랜잭션, 격리수준 차이점
- <span style="background:rgba(240, 107, 5, 0.2)">잠금(Lock)</span>은 <span style="background:rgba(240, 107, 5, 0.2)">동시성</span> 제어기능
- <span style="background:rgba(240, 107, 5, 0.2)">트랜잭션(Transaction)</span>은 <span style="background:rgba(240, 107, 5, 0.2)">데이터의 정합성</span>을 보장하는 기능
- <span style="background:rgba(240, 107, 5, 0.2)">격리수준(Isolation level)</span>은 하나의 트랜잭션 내 or 여러 트랜잭션 간의 <span style="background:rgba(240, 107, 5, 0.2)">작업내용을 어떻게 공유하고 차단 할 것인지를 결정</span>하는 레벨 

### **DB 세션**
- 개발자가 클라이언트를 통해 SQL을 전달하면 현재 커넥션에 연결된 세션이 SQL을 실행
- **세션은 트랜잭션을 시작**하고, **커밋 또는 롤백을 통해 트랜잭션을 종료**
- 사용자가 커넥션을 닫거나, 또는 DB 관리자가 세션을 강제로 종료하면 세션 종료
- 커넥션 수 = 세션 수

## 트랜잭션
- 작업의 완전성을 보장해 주는 것.
- 논리적인 작업 셋을 완벽하게 처리하거나 부분 실패일 경우 원상 복구 해주는 기능
- 꼭 필요한 코드에만 적용하여 트랜잭션의 범위를 최소화 해야함.

### 트랜잭션 특징  : ACID
###### 원자성(Atomicity)  
- 부분적으로 실행되다가 중단되지 않는 것을 보장(바뀌거나 바뀌지 않거나)   

###### 일관성(Consistency)  
-  언제나 일관성 있는 데이터베이스 상태로 유지(성공 후 반영 상태 유지)  

###### 독립성(Isolation)  - 트랜잭션의 격리 수준
-  다른 트랜잭션의 연산 작업이 끼어들지 못하도록 보장(작업 중인 데이터를 볼 수 없음)  

###### 지속성(Durability)  
- 트랜잭션이 성공적으로 수행되면 영원히 반영되어야 한다(커밋된 데이터는 비휘발성 메모리에 남음)

## 데이터베이스 병행 제어 기법
- 데이터베이스의 일관성을 유지하면서 시스템 활용과 공유를 최대화 하고 사용자의 응답시간을 최소화 하기 위해 사용한다.
- Locking은 병행 제어 기법 중 하나. 

## Locking
- 한 트랜잭션이 접근하려는 데이터를 다른 트랜잭션이 접근하지 못하도록 잠그는 기법
- 교착 상태(Deadlock)이 발생할 수 있다는 단점이 있음

### Lock의 설정 범위
- **테이블**
	테이블을 기준으로 Lock을 설정
	DDL(create, alter, drop 등) 구문과 함께 사용
 - **행**
	1개의 행을 기준으로 Lock을 설정
	**DML**에 대한 Lock으로 **가장 기본으로 사용하는 Lock**

### Lock의 종류
#### <span style="background:rgba(240, 200, 0, 0.2)">공유 락(Shared lock)</span> - 읽기 O, 쓰기 X
- 데이터를 변경하지 않는 읽기 명령에 대해 주어지는 락 - Read lock
- 여러 사용자가 동시에 데이터를 읽어도 데이터의 일관성에는 아무런 영향을 주지 않기 때문에, 공유 락끼리는 동시에 접근이 가능
- 같은 레코드에 대해 읽기 락이 여러개 존재할 수 있어 공유(share) 락이라고 한다.
- `S`락  

#### <span style="background:rgba(240, 200, 0, 0.2)">배타적 락(Exclusive lock)</span> - 읽기 X, 쓰기 X
- 데이터에 변경을 가하는 쓰기 명령들에 대해 주어지는 락 - Write lock
- 다른 세션이 해당 자원에 접근(`SELECT`, `INSERT`..) 하는 것을 막음.
- 읽기 연산은 트랜잭션 격리 레벨을 어떻게 설정하느냐에 따라 허용할 수도, 안할 수도 있음
- `X`락. 

#### <span style="background:rgba(240, 200, 0, 0.2)">업데이트 락(Update Lock)</span>
- 데이터를 수정하기 위해 베타 락을 걸기 전, 데드락을 방지하기 위해 사용되는 락
- 업데이트 쿼리의 필터가 실행될 때 적용(where 절)  

#### <span style="background:rgba(240, 200, 0, 0.2)">내재 락(Intent Lock)</span>
- 사용자가 요청한 범위에 대한 락(테이블 락)을 걸 수 있는지 여부를 빠르게 파악하기 위해 사용되는 락
- 공유 락과 베타 락 앞에 `I` 기호를 붙임

### 블로킹 (Blocking)
- Lock들의 경합(Race Condition)이 발생하여 특정 세션이 작업을 진행하지 못하고 멈춰선 상태
- **공유 락<-> 배타적 락** 또는, **배타적 락 <->  배타적 락** 끼리 **블로킹이 발생**
- 이전 트랜잭션이 commit 또는 rollback을 해야 해결
- Race Condition이 발생하면 먼저 Lock을 설정한 트랜잭션을 기다려야 함

![](https://i.imgur.com/oPrunY4.png)
**해결 방안**  
1. (기본)SQL 문장이 가장 빠르게 실행되도록 리펙토링  
2. 트랜잭션을 가능한 짧게 정의  
3. 동일한 데이터를 동시에 변경하는 작업을 하지 않도록 설계  
4. 대용량 갱신 작업은 트랜잭션이 적은 시간에 진행  
5. 대용량 작업이 불가피할 경우, 작업 단위를 쪼개거나 LOCK_TIMEOUT을 설정하여 해당 Lock의 최대 시간을 설정

## 데드락(Deadlock)
- 두 개 이상의 트랜잭션들이 동시에 진행될 때 서로가 서로에 대한 락을 소유한 상태로 대기 상태로 빠져서 더 이상 진행하지 못하는 상황
- 트랜잭션을 지원하는 데이터베이스에서는 자주 발생
- 멀티 스레드(Multi-threaded) 어플리케이션에서 발생하면 서비스 장애
- 일반적인 DBMS에서는 데드락 탐지(Deadlock detection) 기능을 제공하기 때문에 데드락이 발견되면 자동으로 해소 (실제 데드락 상황이 아닐지라도 락에 대한 대기시간이 설정된 시간을 초과하면 이것도 데드락으로 처리)
- 이 과정에서 작업중이던 트랜잭션들 중 일부가 취소되는 경우가 발생 할 수 있기 때문에 어플리케이션 레벨에서 해당 트랜잭션을 재 실행 하여 작업을 완수할 수 있도록 구성 해야 함

### 데드락(Deadlock)을 해결하는 방법
- 트랜잭션 진행 방향을 같은 방향으로 설계
- 트랜잭션 처리 속도를 최소화
- 잠금 시간을 설정하여 무기한 대기하지 않고 중간에 잠금이 풀리도록 설정



[[데이터베이스] 잠금이란? (tistory.com)](https://steady-coding.tistory.com/552)  

[https://hstory0208.tistory.com/entry/락Lock이란-Lock의-종류와-교착상태DeadLock](https://hstory0208.tistory.com/entry/%EB%9D%BDLock%EC%9D%B4%EB%9E%80-Lock%EC%9D%98-%EC%A2%85%EB%A5%98%EC%99%80-%EA%B5%90%EC%B0%A9%EC%83%81%ED%83%9CDeadLock)  

[[Database] 데이터베이스 락(Lock)의 종류와 역할 (velog.io)](https://velog.io/@koo8624/Database-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EB%9D%BDLock%EC%9D%98-%EC%A2%85%EB%A5%98%EC%99%80-%EC%97%AD%ED%95%A0)  

[Database - 교착상태 문제를 해결하는 방법! (tistory.com)](https://jaehoney.tistory.com/162)

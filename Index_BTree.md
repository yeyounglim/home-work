# <데이터베이스 Index>
### HDD에 데이터베이스를 저장할 때
- 데이터베이스의 데이터는 하드디스크에 저장된다.
- 데이터는 블록 단위로 저장된다.(블록 주소는 트랙번호, 섹터번호로 구성)
- 저장된 데이터를 찾기 위해서는 풀 스캔을 해야한다.
- 이 시간을 줄일 수 있는 방법이 인덱스 사용이다.

- 인덱스를 생성하면 디스크에 인덱스를 추가로 저장한다.
- 인덱스는 키(데이터)와 포인터(데이터가 저장된 블록의 위치)를 저장한다.
- 데이터를 찾기 위해 인덱스를 먼저 찾은 후 데이터가 저장된 위치를 알아내어 접근할 수 있다.

- 데이터가 늘어나면 인덱스의 양이 늘어나게 된다.
- 인덱스의 인덱스를 생성 할 수 있다.(멀티 레벨 인덱스)
- 인덱스도 블록 단위로 저장되기 때문에 인덱스의 인덱스는 한 블록의 위치를 저장한다.
- 인덱스의 레벨을 늘리면 데이터를 조회하기 위한 블록 액세스의 횟수를 줄일 수 있다.

- 이 인덱스를 효과적으로 관리하기 위한 자료구조가 B-tree이다.(기본적으로 많이 사용 함)


## 인덱스(Index)란?

데이터베이스 테이블의 검색 성능의 속도를 높여주는 자료 구조

### 인덱스(Index)를 사용하는 이유 
- 인덱스는 데이터가 정렬이 되어있어 조건문을 빠르게 조회 가능
- 빠르게 정렬하거나 그룹핑하기 위해 사용

##### 1. 조건 검색 Where 절의 효율성
- 풀 테이블 스캔 (Full Table Scan) 방지
- 인덱스 테이블은 데이터들이 정렬되어 저장되어 있기 때문에 해당 조건 (Where)에 맞는 데이터들을 빠르게 찾을 수 있음

##### 2. 정렬 Order by 절의 효율성
- 인덱스(Index)를 사용하면 Order by에 의한 Sort를 하지 않아도 됨
- 정렬을 하게 되면 1차적으로 메모리에서 정렬이 이루어지고, 
메모리보다 큰 작업이 필요하면 디스크 I/O도 추가적으로 발생하여 속도가 지연된다.

##### 3. MIN, MAX의 효율적인 처리 가능
- MIN값과 MAX값을 레코드의 시작값과 끝 값 한 건씩만 가져오면 된다

### **인덱스를 사용하면 좋은 경우**

- 데이터의 range가 넓고 중복이 적을수록, 조회가 많거나 정렬된 상태가 유용한 컬럼에 사용
- 규모가 큰 테이블
- 삽입(INSERT), 수정(UPDATE), 삭제(DELETE) 작업이 자주 발생하지 않는 컬럼
- WHERE나 ORDER BY, JOIN 등이 자주 사용되는 컬럼
- 데이터의 중복도가 낮은 컬럼

### 인덱스(Index)의 단점 
- 정렬된 상태를 계속 유지 시켜줘야 한다.
- 데이터가 추가되거나 값이 바뀌면 INDEX 테이블 내에 있는 값들을 다시 정렬 해야한다. 
- INDEX 테이블, 원본 테이블 이렇게 두 군데에 데이터 수정 작업해 줘야 한다.
- 테이블의 전체 데이터 중에서 10~15% 이하의 데이터를 처리하는 경우에만 효율적
-  인덱스를 관리하기 위해서는 데이터베이스의 약 10%에 해당하는 저장공간이 추가로 필요

### 인덱스(Index)의 관리
- 인덱스가 변경되면 재 정렬을 해야 하는데 이 부하를 최소화하기 위해 인덱스는 데이터 삭제가 아니라 사용 하지 않음 처리를 한다.

## 인덱스의 자료구조
- 해시 테이블(Hash Table)
- B+Tree (Balanced Tree)

### B-Tree
- 탐색 성능을 높이기 위해 균형 있게 높이를 유지하는 Balanced Tree의 일종
-  모든 leaf node가 같은 level로 유지되도록 자동으로 밸런스를 맞춤
- node의 자식 수 중 최댓값을 K라고 하면, 해당 B-Tree를 K차 B-Tree 라고 한다.
![](https://i.imgur.com/MW1zhVo.png)

#### B-Tree의 조건
1. node의 key의 수가 k개라면, 자식 node의 수는 k+1개이다. 
2. node의 key는 반드시 정렬된 상태여야 한다. 
3. 자식 node들의 key는 현재 node의 key를 기준으로 크기 순으로 나뉘게 된다. 
4. root node는 항상 2개 이상의 자식 node를 갖는다. (root node가 leaf node인 경우 제외) 
5. M차 트리일 때, root node와 leaf node를 제외한 모든 node는 최소 ⌈M2⌉⌈M2⌉, 최대 MM개의 서브 트리를 갖는다. 
6. 모든 leaf node들은 같은 level에 있어야 한다.

### 해시 테이블(Hash Table)
- 해시 테이블은 key와 value를 한 쌍으로 데이터를 저장하는 자료구조
- 해시 충돌이라는 변수가 존재하지만 평균적으로 시간 복잡도 O(1)
- 등호(=) 연산에 최적화 되어 있어 실제로 인덱스에서 잘 사용되지 않음

### B+Tree 
- B-Tree의 단점을 개선시킨 자료구조
- B-Tree는 어느 한 데이터의 검색은 효율적이지만, 모든 데이터를 한 번 순회하는 데에는 트리의 모든 노드를 방문해야 하므로 비효율적
- leaf node에만 데이터를 저장하고 leaf node가 아닌 node에서는 자식 포인터만 저장
- leaf node끼리는 Linked list로 연결

![](https://i.imgur.com/1Ji9GJK.png)

#### B+Tree 장점
- leaf node를 제외하고 데이터를 저장하지 않기 때문에 메모리를 더 확보할 수 있다.
- Full scan을 하는 경우 B+Tree는 leaf node에만 데이터가 저장되어 있고, leaf node끼리 linked list로 연결되어 있기 때문에 선형 시간이 소모 (B-Tree는 모든 node를 확인)

#### B+Tree 단점
- 특정 key에 접근하기 위해서 leaf node까지 가야 한다.
- 중간 node에서 key를 올바르게 찾아가기 위해서 key가 중복될 수 있다.

#### B-Tree 대신 주로 B+Tree를 사용하는 이유
- 인덱스 컬럼은 부등호를 이용한 순차 검색 연산이 자주 발생
- B+Tree의 Linked list를 이용하면 순차 검색을 효율적으로 할 수 있게 된다.  



 [https://rebro.kr/167](https://rebro.kr/167) 
 
 [https://code-lab1.tistory.com/217](https://code-lab1.tistory.com/217)
